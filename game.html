<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zathura Flyer</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            background-color: #000;
            font-family: 'Arial', sans-serif;
            color: #E0E0E0;
            overflow: hidden;
            touch-action: manipulation;
        }
        #game-container {
            position: relative;
            width: 100%;
            max-width: 400px;
            height: 80vh;
            max-height: 600px;
            overflow: hidden;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
            border-radius: 15px;
            border: 3px solid #00FFFF;
            background: #000;
        }
        #three-container {
            width: 100%; 
            height: 100%;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            background-color: transparent;
        }
        #score-display {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 3.5em;
            font-weight: 900;
            color: #00FFFF;
            text-shadow: 0 0 15px #00FFFF;
            z-index: 100;
            user-select: none;
        }
        #message-box {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
            text-align: center;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s;
            border-radius: 15px;
            cursor: pointer;
        }
        #message-box.active {
            opacity: 1;
            visibility: visible;
        }
        h1 {
            color: #FFD700;
            text-shadow: 0 0 10px #FFA500;
            font-size: 3em;
            margin-bottom: 5px;
        }
        .final-score {
            font-size: 2em;
            color: #00FFFF;
            margin-bottom: 5px;
        }
        #retry-instruction {
            font-size: 1.2em;
            color: #E0E0E0;
            margin-top: 30px;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }
    </style>
    <!-- Telegram Game SDK -->
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <!-- Three.js for 3D rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Tone.js for Sound and Music Generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
</head>
<body>
    <div id="game-container">
        <!-- Three.js will render into this container -->
        <div id="three-container"></div>
        
        <div id="score-display">0</div>

        <!-- Start/Instruction Screen -->
        <div id="start-screen" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.9); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 300; cursor: pointer;">
            <h1 style="font-size: 2.5em; margin-bottom: 20px;">ðŸš€ ZATHURA FLYER</h1>
            <p style="font-size: 1.2em; color: #00FFFF;">TAP ANYWHERE TO THRUST</p>
            <p style="font-size: 1em; color: #E0E0E0; margin-top: 10px;">AVOID THE BLACK HOLE ANOMALIES</p>
            <p style="font-size: 0.8em; color: #FFD700; margin-top: 30px;">(Click to Start)</p>
        </div>

        <!-- Game Over Screen (Now the universal retry button) -->
        <div id="message-box">
            <h1>GAME OVER</h1>
            <p class="final-score">Final Score: <span id="final-score-value">0</span></p>
            <p class="final-score">High Score: <span id="high-score-value">0</span></p>
            <p id="high-score-message"></p>
            <p id="retry-instruction">TAP ANYWHERE TO RETRY</p>
        </div>
    </div>

    <script>
        const scoreDisplay = document.getElementById('score-display');
        const messageBox = document.getElementById('message-box');
        const finalScoreValue = document.getElementById('final-score-value');
        const highScoreValue = document.getElementById('high-score-value');
        const highScoreMessage = document.getElementById('high-score-message');
        const startScreen = document.getElementById('start-screen');
        const threeContainer = document.getElementById('three-container');

        // --- THREE.JS GLOBALS ---
        let scene, camera, renderer;
        let playerMesh, light;
        let pipes = [];
        let clock = new THREE.Clock();

        // --- GAME VARIABLES ---
        let score, isGameOver;
        let playerY = 0;
        let playerVelocity = 0;
        const gravity = 0.0055;
        const lift = -0.15;
        const PIPE_GAP = 3.5;
        const PIPE_WIDTH = 0.5;
        const PIPE_SPEED = 0.015;
        const PIPE_INTERVAL_TIME = 1500;
        let lastPipeTime = 0;
        let gameRunning = false;
        
        // --- WORLD COORDINATES
        const WORLD_HEIGHT = 5;
        const WORLD_DEPTH = 10;
        const WORLD_X_PLAYER = -3;
        const CAMERA_Z = 6;

        // --- SOUND MANAGER (TONE.JS) ---
        const SoundManager = {
            initialized: false,
            bgm: null,
            jumpSynth: null,
            scoreSynth: null,
            endNoise: null,

            init() {
                if (this.initialized) return;
                this.bgm = new Tone.PolySynth(Tone.Synth, {
                    volume: -15,
                    oscillator: { type: "sine" },
                    envelope: { attack: 2, decay: 1, sustain: 0.8, release: 3 }
                }).toDestination();
                
                this.jumpSynth = new Tone.Synth({
                    volume: -15,
                    oscillator: { type: "triangle" },
                    envelope: { attack: 0.005, decay: 0.1, sustain: 0.1, release: 0.3 }
                }).toDestination();

                this.scoreSynth = new Tone.MembraneSynth({
                    volume: -10, pitchDecay: 0.05, octaves: 2,
                    envelope: { attack: 0.001, decay: 0.4, sustain: 0.01, release: 0.4 }
                }).toDestination();

                this.endNoise = new Tone.NoiseSynth({
                    volume: -10,
                    noise: { type: "brown" },
                    envelope: { attack: 0.001, decay: 1.0, sustain: 0.0, release: 1.0 }
                }).toDestination();

                this.initialized = true;
            },

            playJump() { this.jumpSynth.triggerAttackRelease("C5", "8n"); },
            playScore() { this.scoreSynth.triggerAttackRelease("G4", "16n"); },
            playGameOver() { this.endNoise.triggerAttackRelease("1n"); },

            startBGM() {
                if (Tone.Transport.state === 'started') return;
                const part = new Tone.Sequence((time, note) => {
                    this.bgm.triggerAttackRelease(note, "4n", time);
                }, [["C3", "G3", "Bb3"], ["C3", "F3", "Ab3"], ["D3", "A3", "C4"], ["G2", "B2", "D3"]], "1n").start(0);
                Tone.Transport.loop = true;
                Tone.Transport.loopEnd = "4n";
                Tone.Transport.start();
            },
            
            stopBGM() {
                Tone.Transport.stop();
                Tone.Transport.cancel(0);
            }
        };


        // --- THREE.JS SETUP ---

        function setupThreeJS() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a1a); 

            // Camera setup 
            const containerWidth = threeContainer.clientWidth;
            const containerHeight = threeContainer.clientHeight;
            const aspectRatio = containerWidth / containerHeight;
            const viewSize = WORLD_HEIGHT; 
            
            camera = new THREE.OrthographicCamera(
                viewSize * aspectRatio / -2, viewSize * aspectRatio / 2,
                viewSize / 2, viewSize / -2, 
                0.1, 100 
            );
            camera.position.z = CAMERA_Z;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(containerWidth, containerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            
            // Append the renderer to the container here
            if (threeContainer.children.length === 0) {
                 threeContainer.appendChild(renderer.domElement);
            }


            // Lighting
            light = new THREE.PointLight(0xffffff, 1, 100);
            light.position.set(0, 0, 5);
            scene.add(light);
            scene.add(new THREE.AmbientLight(0x404040, 2)); 

            // Background Stars/Nebula
            const starsGeometry = new THREE.BufferGeometry();
            const starsMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.05, blending: THREE.AdditiveBlending, transparent: true, opacity: 0.7 });
            const starVertices = [];
            for (let i = 0; i < 500; i++) {
                const x = (Math.random() - 0.5) * 50;
                const y = (Math.random() - 0.5) * 50;
                const z = (Math.random() - 0.5) * 50;
                starVertices.push(x, y, z);
            }
            starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            scene.add(new THREE.Points(starsGeometry, starsMaterial));
        }

        function createPlayerMesh() {
            const bodyGeo = new THREE.BoxGeometry(0.5, 0.3, 0.3);
            const noseGeo = new THREE.ConeGeometry(0.15, 0.3, 8);
            const mat = new THREE.MeshPhongMaterial({ color: 0xcccccc, shininess: 30 });

            const body = new THREE.Mesh(bodyGeo, mat);
            const nose = new THREE.Mesh(noseGeo, mat);

            nose.position.set(-0.25, 0, 0);
            nose.rotation.z = Math.PI / 2;

            const playerGroup = new THREE.Group();
            playerGroup.add(body, nose);
            
            playerGroup.rotation.y = Math.PI / 2;
            
            playerMesh = playerGroup;
            playerMesh.position.set(WORLD_X_PLAYER, 0, 0);
            scene.add(playerMesh);
        }

        function createPipe(gapY) {
            const anomalyGroup = new THREE.Group();
            const material = new THREE.MeshPhongMaterial({ color: 0x000000, shininess: 10 });
            
            // Top Anomaly
            const topSphere = new THREE.Mesh(
                new THREE.SphereGeometry(PIPE_WIDTH, 16, 16),
                material
            );
            topSphere.position.set(0, gapY + PIPE_GAP / 2, 0);
            topSphere.castShadow = true;
            
            // Bottom Anomaly
            const bottomSphere = new THREE.Mesh(
                new THREE.SphereGeometry(PIPE_WIDTH, 16, 16),
                material
            );
            bottomSphere.position.set(0, gapY - PIPE_GAP / 2, 0);
            bottomSphere.castShadow = true;

            // Accretion Disk Glow
            const glowLightColor = 0xFFA500; 
            const topGlow = new THREE.PointLight(glowLightColor, 0.5, 3);
            topGlow.position.copy(topSphere.position);
            
            const bottomGlow = new THREE.PointLight(glowLightColor, 0.5, 3);
            bottomGlow.position.copy(bottomSphere.position);

            anomalyGroup.add(topSphere, bottomSphere, topGlow, bottomGlow);
            
            anomalyGroup.position.set(WORLD_DEPTH, 0, 0); 
            anomalyGroup.userData.scored = false;
            anomalyGroup.userData.pipeRadius = PIPE_WIDTH;

            scene.add(anomalyGroup);
            return anomalyGroup;
        }

        // --- COLLISION AND GAME LOGIC ---

        function check3DCollision() {
            const playerPos = playerMesh.position;
            const playerRadius = 0.5; 

            for (let i = pipes.length - 1; i >= 0; i--) {
                const pipeGroup = pipes[i];
                const pipePos = pipeGroup.position;
                
                // Get anomaly positions relative to the scene
                const topAnomaly = pipeGroup.children[0];
                const bottomAnomaly = pipeGroup.children[1];

                const topAnomalyPos = new THREE.Vector3().setFromMatrixPosition(topAnomaly.matrixWorld);
                const bottomAnomalyPos = new THREE.Vector3().setFromMatrixPosition(bottomAnomaly.matrixWorld);

                const distanceTop = playerPos.distanceTo(topAnomalyPos);
                const distanceBottom = playerPos.distanceTo(bottomAnomalyPos);
                
                if (Math.abs(playerPos.x - pipePos.x) < 1.5) { 
                    if (distanceTop < playerRadius + pipeGroup.userData.pipeRadius || 
                        distanceBottom < playerRadius + pipeGroup.userData.pipeRadius) {
                        endGame();
                        return true;
                    }
                }

                if (pipePos.x < playerPos.x && !pipeGroup.userData.scored) {
                    score++;
                    scoreDisplay.textContent = score;
                    pipeGroup.userData.scored = true;
                    SoundManager.playScore();
                }
            }

            // Boundary Check (Top and Bottom)
            const halfWorldHeight = WORLD_HEIGHT / 2;
            if (playerPos.y > halfWorldHeight || playerPos.y < -halfWorldHeight) {
                endGame();
                return true;
            }
            return false;
        }


        // --- GAME FLOW ---

        function initGame() {
            if (isGameOver) {
                pipes.forEach(p => scene.remove(p));
                pipes = [];
                scene.remove(playerMesh);
            }
            
            if (!renderer) {
                setupThreeJS();
            }

            createPlayerMesh();
            playerY = 0;
            playerVelocity = 0;
            score = 0;
            isGameOver = false;
            gameRunning = true;
            lastPipeTime = 0;
            scoreDisplay.textContent = score;
            messageBox.classList.remove('active');
            startScreen.style.display = 'none';
            
            SoundManager.startBGM();

            if (!animationFrameId) {
                animate();
            }
        }
        
        async function jump() {
            if (!SoundManager.initialized) {
                await Tone.start();
                SoundManager.init();
            }

            if (isGameOver) {
                initGame();
                return;
            }
            if (!gameRunning) {
                initGame();
                return;
            }
            playerVelocity = lift;
            SoundManager.playJump();
        }

        function endGame() {
            if (isGameOver) return;
            isGameOver = true;
            gameRunning = false;
            SoundManager.stopBGM();
            SoundManager.playGameOver();
            
            const finalScore = score;
            finalScoreValue.textContent = finalScore;
            
            const currentHighScore = localStorage.getItem('telegramFlyerHighScore') || 0;
            
            if (finalScore > currentHighScore) {
                localStorage.setItem('telegramFlyerHighScore', finalScore);
                highScoreValue.textContent = finalScore; 
                highScoreMessage.textContent = `NEW RECORD!`;
            } else {
                highScoreValue.textContent = currentHighScore;
                highScoreMessage.textContent = `Good job!`;
            }

            messageBox.classList.add('active');
        }

        function animate() {
            animationFrameId = requestAnimationFrame(animate);
            const delta = clock.getDelta();
            
            if (gameRunning) {
                const elapsed = clock.getElapsedTime();

                // Player Physics Update
                playerVelocity += gravity;
                playerY += playerVelocity * delta * 60; // Scale movement to delta time * constant
                playerMesh.position.y = playerY;

                // Player Rotation (Tilt)
                playerMesh.rotation.z = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, -playerVelocity * 2));
                
                // Pipe Spawning
                if (elapsed * 1000 - lastPipeTime > PIPE_INTERVAL_TIME) {
                    const gapY = (Math.random() * (WORLD_HEIGHT - PIPE_GAP * 2)) - (WORLD_HEIGHT / 2 - PIPE_GAP);
                    pipes.push(createPipe(gapY));
                    lastPipeTime = elapsed * 1000;
                }

                // Pipe Movement and Removal
                for (let i = pipes.length - 1; i >= 0; i--) {
                    const pipeGroup = pipes[i];
                    pipeGroup.position.x -= PIPE_SPEED * delta * 60; 

                    if (pipeGroup.position.x < -WORLD_DEPTH / 2) {
                        scene.remove(pipeGroup);
                        pipes.splice(i, 1);
                    }
                }
                
                check3DCollision();
            }
            
            renderer.render(scene, camera);
        }

        // --- INITIALIZATION ---
        
        function setupEventListeners() {
            document.getElementById('game-container').addEventListener('click', jump);
            startScreen.addEventListener('click', jump);
            messageBox.addEventListener('click', jump);
        }

        window.addEventListener('resize', () => {
            if (renderer) {
                const containerWidth = threeContainer.clientWidth;
                const containerHeight = threeContainer.clientHeight;
                const aspectRatio = containerWidth / containerHeight;
                const viewSize = WORLD_HEIGHT;

                camera.left = viewSize * aspectRatio / -2;
                camera.right = viewSize * aspectRatio / 2;
                camera.top = viewSize / 2;
                camera.bottom = viewSize / -2;
                camera.updateProjectionMatrix();
                
                renderer.setSize(containerWidth, containerHeight);
            }
        });
        
        window.onload = () => {
            // Initial setup and render on load to make the scene visible
            setupThreeJS();
            animate(); // Start the animation loop immediately to render the background
            gameRunning = false; // Pause the game loop
            startScreen.style.display = 'flex';
            setupEventListeners();
        };

    </script>
</body>
</html>
